## 🔔 ref && out
c#에서는, 기본적으로 메소드에 인자들을 넣으면 새로운 메모리에 해당 인자의 스택 값을 복사하여 넣게 된다.<br>
이것을 Call by Value, 값에 의한 호출이라고 한다. 그렇다 기본적으로 ⭐ **c#은 call by value 형식이다.**<br>
 
⭐⭐ **call by value에 의해 값형식은 그대로 새로운 값이 새로운 메모리에 할당되는 것이며,<br>
참조형식의 경우에는 주소가 다른 메모리에 힙메모리를 가르키는 주소가 복사되는 것이다.** ⭐⭐<br>

여기서 주의해야할 점은, 내부적으로 메소드에서 어떤 조작을 하더라도 값형식은 기존의 값이 변형되지 않는다.<br>
예를 들면 아래처럼 코드를 실행해보자<br>

```c#
int a = 3;

add(a); // add는 인자값에 3을 더 한다.

Console.Writeline(a); 
```
<br>

콘솔에는 어떤 값이 나올까? <br>
6이 아니라 3이 나온다. 새로운 메모리에 3과 같은 값이 저장됐고, 새로운 메모리에 저장된 값이 6이 되었다.<br>
그러나 그 6의 값은 add함수가 끝나면서 정리됐을 것이다.<br>
그리고 콘솔에는 그대로 a의 값인 3이 나온다.<br>
<br>
 
반대로 어떤 객체의 값을 넣는다면 어떻게 될까?<br>
메소드의 복사형식은 스택값을 복사해서 새로운 메모리에 할당하는 것인데,<br>
⭐ **새로운 메모리에 할당된 값은 주소값이고, 결국 같은 힙메모리에 있는 값을 가르키게 된다.**<br>

그래서 add함수에 int가 아니라 참조형식의 값을 넣으면 **실제로 값이 변형된다.**<br>

call by value의 개념을 익혔다면 이제 call by reference에 대해 알아보자<br>
c#은 메소드에 인자를 전달할 때, call by reference를 실행하는 방법으로 **ref라는 키워드를 제공** 한다.<br>

⭐⭐ **ref 예약어를 사용하면 메소드에서 복사방식이 기존의 '새로운 메모리에 스택값을 복사' 하는 방식이 아닌,<br>
'해당 인자의 스택값'을 가르키게 된다. (call by reference방식)** ⭐⭐<br>

즉, 넣는 인자값과 **동일한 스택메모리를 가르키게** 되어서,<br>
ref를 사용한 메소드는 int처럼 값형식을 넣어도 메소드가 끝난 뒤에는 값이 변형될 수 있다.<br>

⭐⭐ **참조형식은 분명 그냥 복사와 ref를 활용한 복사는 다르지만, 결과에 크게 다르진 않다.<br>
다른점은 동일한 주소를 각각 다른 스택 메모리를 통해 접근하느냐, 아니면 같은 메모리를 통해 접근하느냐이다.** ⭐⭐<br>

물론 out 키워드를 이용해서도 Call by Ref 방식을 구현할 수 있지만 두 키워드에는 다음과 같은 차이가 존재한다.<br>

👉 **차이점**<br>
- ref 매개 변수는 사용하기 전에 초기화 해야 함.<br>
- out 매개 변수는 전달하기 전에 초기화할 필요가 없고 이전의 값은 모두 무시함.<br>
- ref로 받은 매개변수는 함수 내에서 참조 혹은 값의 변경이 가능하지만 초기화되지 않은 값은 받을 수 없음.<br>
- out으로 받은 매개변수는 함수 내에서 반드시 초기화될 목적으로 받으며, 함수 내에서 반드시 초기화가 이루어져야 함.<br>
- out으로 받은 매개변수는 함수 내에서 사용이 불가능하다.<br>
<br>

👉 **Out은 좀 더 제한적인 상황에서 사용되며, 메서드 내에서 생성된 값을 반환할 때 사용된다.<br>
-> 메서드가 여러개의 결과 값을 생성하는 경우 반환 값과 함께 사용되는 것이 대부분이다.**<br>
<br>
<br>

## 🔔 in
**in 또한 매개변수를 참조로 전달 받게하는 키워드이다.**<br>
ref와 거의 동일하다고 할 수 있는데, 한가지 다른점은<br>
**메소드 내부에서 해당 값을 변경할 수 없다는 것이다.**<br>

![in](https://user-images.githubusercontent.com/43705434/133825572-2f15d0f8-411d-4355-a26a-5fec8d00d5fb.PNG)<br>
<br>

즉 ref로 매개변수를 받았을 때에는 읽기, 쓰기가 모두 가능했지만<br>
**in으로 참조를 받게되면 읽기만 가능한 것이다.**<br>
<br>
<br>
