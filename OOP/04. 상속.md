상속은 객체지향의 핵심 기능 중에 하나로 대상이 되는 클래스의 모든 특징들을 물려 받는 것을 말합니다. 

 

어떤 임의의 클래스 B가 다른 클래스 A를 상속 받게 되면 A 클래스의 속성과 행위들을 모두 물려받게 됩니다. 

이 때 클래스 A와 B는 상속 관계(inheritance relation)에 있다고 하며 클래스 A를 부모 클래스(parent class), 클래스 B를 자식 클래스(child class)라고 부릅니다. 
어떤 클래스를 이미 상속 받은 클래스를 다시 다른 클래스가 상속을 받을 수 있습니다. 

WheeledVehicle 클래스는 Vehicle 클래스의 Child 클래스인 동시에 Bicycle이나 Car 클래스의 Parent 클래스가 되는 것이죠.

 

그렇게 되면 클래스 간의 관계가 위와 같은 계층형 구조(hierachical structure)를 형성하게 되는데요,

이런 형태의 관계에서는 아래로 내려갈수록 구체화(specialize)된다고 하고 위로 갈수록 일반화(generalize)된다고 표현합니다. 

 

클래스가 구체화 될수록 고유의 특징들이 더 많이 생겨나게 되고, 일반화 될수록 더 많은 객체에 영향을 주게 됩니다. 

 

부모 클래스로부터 특징들을 물려받게 되면 이미 구현된 세부 내용을 다시 구현할 필요가 없기 때문에 코드의 재사용성(resusability)이 향상됩니다. 

많은 분들이 클래스 간의 상속 관계를 형성 할 때 이처럼 코드의 재사용성에 주안점을 두게 되는데 자칫하면 더 큰 혼란을 야기할 수 있어 주의가 필요합니다. 

 

상속 관계가 성립하려면 두 클래스 간의 관계가 is-a 관계여야 합니다.  is-a 관계란 [~은 ~이다] 라고 부를 수 있는 관계입니다. (예를들면 바나나는 과일이다)

즉, 자식 클래스가 들어간 문장이 있을 때 자식 클래스를 부모 클래스로 대체하여도 의미가 성립되어야 합니다. 

 

위 그림에 있는 WheeledVehicle 은 "바퀴가 있는 탈 것"이라는 뜻입니다. 

자동차(Car)는 WheeledVehicle 이다.

자전거(Bicycle)은 WheeledVehicle 이다. 

보트(Boat)는 Vehicle 이다. 

세 문장 모두 is-a 관계에 있기 때문에 제대로 된 상속 관계라고 볼 수 있습니다. 

 

일반적으로 가장 많이 하는 실수는 has-a 관계인 클래스를 상속하는 경우입니다.

has-a 관계는 사람-팔, 자동차-바퀴, 새-날개 등을 예로 들 수 있습니다. 

즉, 하나의 클래스가 다른 클래스의 일부로 속할 때 has-a 관계가 성립됩니다.

 

이러한 has-a 관계의 클래스를 코드 재사용성 측면만 고려하여 상속을 하게 되면 자연스러운 모델링이 되지 못하고 큰 혼란을 불러 올 수 있습니다. 

 

그렇다면 상속은 어떠한 경우에 사용하는 것이 좋을까요?

바로 다음에 설명드릴 다형성을 구현하기 위해서 사용하는 것을 권장드립니다.

물론 기본적으로 is-a 관계가 성립되어야 겠죠?


```c#
// 베이스 클래스
public class Animal
{
   public string Name { get; set; }
   public int Age { get; set; }
}

// 파생클래스
public class Dog : Animal
{       
   public void HowOld() 
   {
      // 베이스 클래스의 Age 속성 사용
      Console.WriteLine("나이: {0}", this.Age);
   }
}

public class Bird : Animal
{       
   public void Fly()
   {
      Console.WriteLine("{0}가 날다", this.Name);
   }
}
```



상위 객체를 재사용해서 하위 객체를 빨리 개발할 수 있도록 한다.



반복된 코드의 중복을 줄여준다



유지 보수의 편리성을 제공해 준다.



클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련합니다.


즉, 하위 객체에서 상위객체의 필드와 메소드를 따로 또 만들어서 사용할 필요가 없으며 상위 객체의 메소드에 문제가 있을 경우 상위 객체에서의 수정으로 인해 하위객체에서 문제가 있었던 메소드를 따로 수정할 필요없이 메소드를 사용할 수 있습니다.

as 연산자와 is 연산자
C#의 as 연산자는 객체를 지정된 클래스 타입으로 변환하는데 사용한다. 만약 변환이 성공하면 해당 클래스 타입으로 캐스팅하고, 변환이 실패하면 null 을 리턴한다.

이와는 대조적으로 캐스팅(Casting)을 사용하면, 변환이 실패했을 때 Exception을 발생시키게 되는데, 이를 catch하지 않으면 프로그램을 중지하게 된다.

C#의 is 연산자는 is 앞에 있는 객체가 특정 클래스 타입이나 인터페이스를 갖고 있는지 확인하는데 사용한다.
```c#
class MyBase { }
class MyClass : MyBase { }

class Program
{
    static void Main(string[] args)
    {
        MyClass c = new MyClass();
        new Program().Test(c);
    }

    public void Test(object obj)
    {
        // as 연산자
        MyBase a = obj as MyBase; 

        // is 연산자
        bool ok = obj is MyBase; //true

        // Explicit Casting
        MyBase b = (MyBase) obj; 
    }
}
```



https://www.csharpstudy.com/CSharp/CSharp-inheritance.aspx
