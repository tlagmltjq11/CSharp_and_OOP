## 상속
상속은 객체지향의 핵심 기능 중에 하나로 대상이 되는 클래스의 모든 특징들을 물려 받는 것을 말한다.<br>
어떤 임의의 클래스 B가 다른 클래스 A를 상속 받게 되면 A 클래스의 속성과 행위들을 모두 물려받게 된다.<br> 
이 때 클래스 A와 B는 상속 관계(inheritance relation)에 있다고 하며 클래스 A를 부모 클래스(parent class),<br>
클래스 B를 자식 클래스(child class)라고 부른다.<br> 

WheeledVehicle 클래스는 Vehicle 클래스의 Child 클래스인 동시에 Bicycle이나 Car 클래스의 Parent 클래스가 되는 경우처럼,<br>
어떤 클래스를 이미 상속 받은 클래스를 다시 다른 클래스가 상속을 받을 수 있다.<br>

그렇게 되면 클래스 간의 관계가 위와 같은 계층형 구조(hierachical structure)를 형성하게 되는데,<br>
이런 형태의 관계에서는 아래로 내려갈수록 구체화(specialize)된다고 하고 위로 갈수록 일반화(generalize)된다고 표현한다.<br> 

부모 클래스로부터 특징들을 물려받게 되면 이미 구현된 세부 내용을 다시 구현할 필요가 없기 때문에 코드의 재사용성(resusability)이 향상된다.<br> 
클래스 간의 상속 관계를 형성 할 때 이처럼 코드의 재사용성에 주안점을 두게 되는데 자칫하면 더 큰 혼란을 야기할 수 있어 주의가 필요하다.<br> 

상속 관계가 성립하려면 두 클래스 간의 관계가 is-a 관계여야 한다.  is-a 관계란 [~은 ~이다] 라고 부를 수 있는 관계다.<br>
(예를들면 바나나는 과일이다)<br>
즉, 자식 클래스가 들어간 문장이 있을 때 자식 클래스를 부모 클래스로 대체하여도 의미가 성립되어야 한다.<br> 

위 그림에 있는 WheeledVehicle 은 "바퀴가 있는 탈 것"이라는 뜻이다.<br> 
* 자동차(Car)는 WheeledVehicle 이다.<br>
* 자전거(Bicycle)은 WheeledVehicle 이다.<br> 
* 보트(Boat)는 Vehicle 이다. <br>
세 문장 모두 is-a 관계에 있기 때문에 제대로 된 상속 관계라고 볼 수 있다.<br> 
 
일반적으로 가장 많이 하는 실수는 has-a 관계인 클래스를 상속하는 경우다.<br>
has-a 관계는 사람-팔, 자동차-바퀴, 새-날개 등을 예로 들 수 있다.<br> 

즉, 하나의 클래스가 다른 클래스의 일부로 속할 때 has-a 관계가 성립된다.<br>
이러한 has-a 관계의 클래스를 코드 재사용성 측면만 고려하여 상속을 하게 되면 자연스러운 모델링이 되지 못하고 큰 혼란을 불러 올 수 있다.<br> 

그렇다면 상속은 어떠한 경우에 사용하는 것이 좋을까?<br>
바로 다음에 설명드릴 다형성을 구현하기 위해서 사용하는 것을 권장한다.<br>
물론 기본적으로 is-a 관계가 성립되어야 한다.<br>
<br>
<br>


```c#
// 베이스 클래스
public class Animal
{
   public string Name { get; set; }
   public int Age { get; set; }
}

// 파생클래스
public class Dog : Animal
{       
   public void HowOld() 
   {
      // 베이스 클래스의 Age 속성 사용
      Console.WriteLine("나이: {0}", this.Age);
   }
}

public class Bird : Animal
{       
   public void Fly()
   {
      Console.WriteLine("{0}가 날다", this.Name);
   }
}
```
<br>
<br>

## 상속의 장점

클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련합니다.

즉, 하위 객체에서 상위객체의 필드와 메소드를 따로 또 만들어서 사용할 필요가 없으며 상위 객체의 메소드에 문제가 있을 경우 상위 객체에서의 수정으로 인해 하위객체에서 문제가 있었던 메소드를 따로 수정할 필요없이 메소드를 사용할 수 있습니다.

## C# as 연산자 && is 연산자

as 연산자와 is 연산자<br>
C#의 as 연산자는 객체를 지정된 클래스 타입으로 변환하는데 사용한다. 만약 변환이 성공하면 해당 클래스 타입으로 캐스팅하고, 변환이 실패하면 null 을 리턴한다.<br>
이와는 대조적으로 캐스팅(Casting)을 사용하면, 변환이 실패했을 때 Exception을 발생시키게 되는데, 이를 catch하지 않으면 프로그램을 중지하게 된다.<br>
C#의 is 연산자는 is 앞에 있는 객체가 특정 클래스 타입이나 인터페이스를 갖고 있는지 확인하는데 사용한다.<br>

```c#
class MyBase { }
class MyClass : MyBase { }

class Program
{
    static void Main(string[] args)
    {
        MyClass c = new MyClass();
        new Program().Test(c);
    }

    public void Test(object obj)
    {
        // as 연산자
        MyBase a = obj as MyBase; 

        // is 연산자
        bool ok = obj is MyBase; //true

        // Explicit Casting
        MyBase b = (MyBase) obj; 
    }
}
```
<br>
<br>

## 참고링크
https://www.csharpstudy.com/CSharp/CSharp-inheritance.aspx<br>
