## 부동소수점 오차의 원인
그냥 부동소수점이나 고정소수점이나 소수 부분을 2진수로 나타내는 과정에서 어쩔 수 없이 무한소수를 만난 경우
할당받은 bit 단위로 잘라내어 근사치로서 사용해야하기 때문에, 오차가 발생하는것이다.

여기선 부동소수점이 어떠한 공식으로 이루어져있는지 찾아보는것이 나아보인다. 

32.1을 32비트 부동소수점(float) 형식으로 표현하는 과정을 단계별로 설명하겠습니다.

1. 32.1을 2진수로 변환
먼저, 32.1을 2진수로 변환해야 합니다.

1.1 정수 부분 변환
32는 2진수로 100000입니다.
1.2 소수 부분 변환
0.1을 2진수로 변환하면, 반복되는 이진 소수로 표현됩니다.
변환 과정은 다음과 같습니다:

0.1 × 2 = 0.2 → 정수 부분 0
0.2 × 2 = 0.4 → 정수 부분 0
0.4 × 2 = 0.8 → 정수 부분 0
0.8 × 2 = 1.6 → 정수 부분 1
0.6 × 2 = 1.2 → 정수 부분 1
0.2 × 2 = 0.4 → 정수 부분 0 (이후 반복)
따라서, 0.1의 2진 표현은 0.00011001100110011...이 됩니다.

결국, 32.1을 2진수로 표현하면:

scss
코드 복사
32.1 = 100000.00011001100110011... (무한 반복)
2. 정규화 (Normalization)
부동소수점에서는 숫자를 1.xxxx × 2^n 형태로 표현해야 합니다.

32.1의 2진수 표현을 정규화하면 1.0000000011001100110011... × 2^5가 됩니다.
3. 지수 (Exponent)
지수는 5입니다. IEEE 754 표준에 따라 바이어스 값을 적용해야 합니다.

바이어스 값은 127이므로, 지수는 5 + 127 = 132가 됩니다.
132를 2진수로 변환하면 10000100입니다.
4. 가수 (Mantissa)
정규화된 숫자에서, 소수점 이하의 비트들이 가수로 들어갑니다.

1.0000000011001100110011...에서 1.을 생략한 0000000011001100110011이 가수가 됩니다.
남은 비트는 0으로 채워져 총 23비트를 구성합니다.
5. 최종 32비트 부동소수점 표현
최종적으로 32.1의 32비트 부동소수점 표현은 다음과 같이 구성됩니다:

부호 비트 (1비트): 0 (양수이므로)
지수 (8비트): 10000100
가수 (23비트): 00000000110011001100110 (마지막 비트는 근사값으로 잘립니다)
이 값은 다음과 같이 32비트로 나타낼 수 있습니다:

코드 복사
0 10000100 00000000110011001100110
이 결과를 사용하면, 32.1을 부동소수점 방식으로 표현할 수 있습니다. 이 값은 실제로 32.1에 매우 가까운 값을 표현하지만, 소수점 부분의 근사로 인해 약간의 오차가 있을 수 있습니다.

<br>
<br>
<br>
<br>
<br>





실수 0.01를 1000번 더하면 어떻게 될까.<br>
당연하게도 0.01 x 1000 = 10이 나올것인가?<br>

![실수오차](https://user-images.githubusercontent.com/43705434/125295300-0da1b880-e360-11eb-9b20-6d5be8c40389.PNG)<br>
<br>

위 결과를 보면 그렇지 않다는 것을 알 수 있다.<br>
왜 이런 간단한 계산에도 오차가 존재하는 것 일까?<br>
<br>
<br>

⭐ **우선 컴퓨터가 실수를 표현하는 방식을 알아 볼 필요가 있다.**<br>

float형으로 예를 들어보겠다.<br>
float 형은 4바이트 자료형이다. 그렇다면 2바이트 씩 나눠서 정수와 소수를 나타내는 것인가?<br>
그렇지않다. 이 방식은 간단하겠지만 아쉽게도 **너무 적은 양의 데이터** 밖에 저장할 수 없게 된다.<br>
->> **이 방법은 고정 소수점(fixed point) 방식을 의미한다.**<br>

그래서 사용한 방법이 **E 표기법** 이라는 방법이다.<br>

 ![부동소수점](https://user-images.githubusercontent.com/43705434/125294887-a421aa00-e35f-11eb-92f1-67ed4f9b387b.PNG)<br>
<br>

⭐⭐ **지수표기법 이라고도 하는 이 방법은 부호비트를 제외한 나머지 비트를 반으로 나눠서<br>
앞 절반은 소수점을 표현하고, 뒤 절반은 앞 절반에 곱할 값을 표현한다.** ⭐⭐<br>

쉽게 설명하자면 135.482를 표현하고 싶다면 1.35482에서 35482를 앞에 절반비트에서 표현하고<br>
1.35482가 135.482가 돼야하므로 뒤에 절반 비트는 1.35482에 곱해질 100을 표현하는 것이다.<br>
 
이렇게하면 **훨씬 많은 양의 데이터를 표현** 할 수 있게된다.<br>
⭐ **단 가장 큰 문제점은 정확성이다.** 이러한 지수 표기법은 정확성이 떨어지게된다.(⭐ 공식에 의해서)<br>
한가지의 소수점이 있을때는 극 소량의 오차만 포함해서 오차가 크게 나지 않지만<br>
아까처럼 0.01을 1000번 연속해서 더해주면 그 오차가 쌓이고 쌓여 100이 아닌<br>
99.999046이라는 근접하지만 정확하지 않은 값이 나오게 되는 것이다.<br>
<br> 
<br>

## 부동소수점 오차로 인한 문제점

결국 이러한 오차는 다음과 같은 코드에서 문제를 일으킨다.<br>

```c#
if (num == 1f)

    Debug.Log("T");

else

    Debug.Log("F");
```

<br>

결과는 무조건 F일 것이다. 오차로 인해서 num의 값이 정확히 1.0f이 될 수 없기 때문이다.<br>
고로 오차범위를 주고 비교하거나, 무지하게 작은 값인 ⭐ Epsilon ⭐ 을 사용하여야 한다.<br>
<br>
<br>

```c#
if (num - 1f < 엡실론)

    Debug.Log("T");

else

    Debug.Log("F");
```
<br>
<br>
