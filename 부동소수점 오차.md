자 우선 제가 0.01이라는 실수를 1000번 더한 수를 보여드리겠습니다.

에이 10이라구 너무 쉽다구요? 과연 그럴까요?

![실수오차](https://user-images.githubusercontent.com/43705434/125295300-0da1b880-e360-11eb-9b20-6d5be8c40389.PNG)


엥?? 프로그램이 바보인가? 왜 99.999046 이라고 뜨지? 코드 잘못 치신것같은데요? 하실수도 있습니다.

하지만 이 결과는 '정상'입니다. 그 이유를 알아볼까요?

 

우선 프로그램이 실수를 표현하는 방식을 알아 볼 필요가 있는데요!

float형으로 예를 들어보겠습니다


float 형은 4바이트입니다. 그럼 2바이트 2바이트 나눠서

2바이트는 정수부분, 2바이트는 소수부분을 나타내면 되겠네요?

아뇨.. 그렇게 한다면 간단하겠지만 아쉽게도 너무 적은 양의 데이터밖에

담을 수 없게됩니다... 그래서 사용한 방법이 E 표기법 이라는 방법인데요!


 ![부동소수점](https://user-images.githubusercontent.com/43705434/125294887-a421aa00-e35f-11eb-92f1-67ed4f9b387b.PNG)

지수표기법 이라고도 하는 이 방법은

부호비트를 제외한 나머지 비트를 반으로 나눠서

앞에 반은 소수점을 표현하고 뒤에 반은

앞에 반에 나온 값에 곱할 값을 표현합니다



쉽게 설명하자면

135.482를 표현하고 싶다면

1.35482에서 35482를 앞에 절반비트에서 표현하고

1.35482가 135.482가 돼야하므로

뒤에 절반 비트는 1.35482에 곱해질 100을 표현하는겁니다.

 

이렇게하면 훨씬 많은 양의 데이터를 표현할수있겠네요!

 단! 가장 큰 문제점은 정확성입니다. 이러한 지수 표기법은

정확성이 떨어지는데요!

한가지의 소수점이 있을때는 극 소량의 오차만 포함해서

오차가 크게 나지 않습니다만

 

아까 제가 한 방법처럼 0.01을 1000번 연속해서 더해주면

그 오차가 쌓이고 쌓여 100이 아닌

99.999046이라는 근접하지만 정확하지 않은 값이 나오게 됩니다.

 

이 점 매우 중요하니 꼭 꼭 꼭 외워두세요!




결국 이러한 오차는 다음과 같은 코드에서 문제를 일으킵니다.
고로 오차범위를 주고 비교하거나 엡실론을 사용하여야 한다.

f (num == 1f)

    Debug.Log("T");

else

    Debug.Log("F");



결과는 무조건 F일 것입니다. 이런 것은 로직이 문제가 아니라 컴퓨터의 한계인 것이죠.

그래서 무쟈게 작은 값인 Epsilon 값과 비교를 합니다. 대충 아래와 같은 느낌으로 코드를 짜는 것이죠.



if (num - 1f < 엡실론)

    Debug.Log("T");

else

    Debug.Log("F");
