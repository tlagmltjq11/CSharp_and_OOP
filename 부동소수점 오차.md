## 부동소수점 오차의 원인
실수 0.01를 1000번 더하면 어떻게 될까.<br>
당연하게도 0.01 x 1000 = 10이 나올것인가?<br>

![실수오차](https://user-images.githubusercontent.com/43705434/125295300-0da1b880-e360-11eb-9b20-6d5be8c40389.PNG)<br>
<br>

위 결과를 보면 그렇지 않다는 것을 알 수 있다.<br>
왜 이런 간단한 계산에도 오차가 존재하는 것 일까?<br>
<br>
<br>

⭐ **우선 컴퓨터가 실수를 표현하는 방식을 알아 볼 필요가 있다.**<br>

float형으로 예를 들어보겠다.<br>
float 형은 4바이트 자료형이다. 그렇다면 2바이트 씩 나눠서 정수와 소수를 나타내는 것인가?<br>
그렇지않다. 이 방식은 간단하겠지만 아쉽게도 **너무 적은 양의 데이터** 밖에 저장할 수 없게 된다.<br>
->> **이 방법은 고정 소수점(fixed point) 방식을 의미한다.**<br>

그래서 사용한 방법이 **E 표기법** 이라는 방법이다.<br>

 ![부동소수점](https://user-images.githubusercontent.com/43705434/125294887-a421aa00-e35f-11eb-92f1-67ed4f9b387b.PNG)<br>
<br>

⭐⭐ **지수표기법 이라고도 하는 이 방법은 부호비트를 제외한 나머지 비트를 반으로 나눠서<br>
앞 절반은 소수점을 표현하고, 뒤 절반은 앞 절반에 곱할 값을 표현한다.** ⭐⭐<br>

쉽게 설명하자면 135.482를 표현하고 싶다면 1.35482에서 35482를 앞에 절반비트에서 표현하고<br>
1.35482가 135.482가 돼야하므로 뒤에 절반 비트는 1.35482에 곱해질 100을 표현하는 것이다.<br>
 
이렇게하면 **훨씬 많은 양의 데이터를 표현** 할 수 있게된다.<br>
⭐ **단 가장 큰 문제점은 정확성이다.** 이러한 지수 표기법은 정확성이 떨어지게된다.(공식에 의해서)<br>
한가지의 소수점이 있을때는 극 소량의 오차만 포함해서 오차가 크게 나지 않지만<br>
아까처럼 0.01을 1000번 연속해서 더해주면 그 오차가 쌓이고 쌓여 100이 아닌<br>
99.999046이라는 근접하지만 정확하지 않은 값이 나오게 되는 것이다.<br>
<br> 
<br>

## 부동소수점 오차로 인한 문제점

결국 이러한 오차는 다음과 같은 코드에서 문제를 일으킨다.<br>

```c#
if (num == 1f)

    Debug.Log("T");

else

    Debug.Log("F");
```

<br>

결과는 무조건 F일 것이다. 오차로 인해서 num의 값이 정확히 1.0f이 될 수 없기 때문이다.<br>
고로 오차범위를 주고 비교하거나, 무지하게 작은 값인 ⭐ Epsilon ⭐ 을 사용하여야 한다.<br>
<br>
<br>

```c#
if (num - 1f < 엡실론)

    Debug.Log("T");

else

    Debug.Log("F");
```
<br>
<br>
