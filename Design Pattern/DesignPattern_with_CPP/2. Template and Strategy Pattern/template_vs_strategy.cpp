/* 차이점

Template Method Pattern (상속 기반)
1. 실행시간에 정책을 바꿀 수 없다. 
-> edit2 의 AddressEdit의 정책을 런타임 중 바꿀 수 없다.
2. 다른 클래스에서 정책을 가져다 쓸 수 없다.
-> edit2 의 AddressEdit의 정책은 멤버함수에 불과해서 다른 클래스에서 가져다 쓸 수 없다.

Strategy Pattern (포함 기반)
1. 실행시간에 정책을 바꿀 수 있다. 원하는 정책을 담은 클래스를 넘겨주기만 하면 된다.
-> edit3 의 LimitDigitValidator 를 15글자 짜리로 하나 더 생성해서 Edit에게 넘겨주면 교체된다.
2. 다른 클래스에서도 정책을 가져다 쓸 수 있다. (정책의 재사용)
-> edit3 의 LimitDigitValidator 는 다른 ex) MultiEditClass 에서도 충분히 사용가능한 정책 클래스다.


상속기반의 디자인패턴은 유연성이 떨어지며 런타임 중 교체가 힘들다.
포함기반의 디자인패턴은 유연성이 좋고 런타임 중 교체가 좋으며 재사용성도 높다.
-> 디자인패턴의 큰 흐름은 포함기반이 더 좋다는 것을 알 수 있다.

그렇다고 상속기반 패턴이 쓸모없는 것은 아니다.
도형편집기(Shape, Rect, Circle ..) 예제에서 Rect가 재정의한 DrawImp 정책은
있는 그대로가 완전하여 교체될 일도 없고 다른 클래스가 알 필요도 없어 재사용될 일도 없다.
사각형을 그리는 정책은 사각형만 알면 되기 때문..


★결론★
고로 재사용성, 실행 중 교체가 필요하다면 전략패턴을 사용하고 그렇지않다면 템플릿메소드 패턴을 사용하면 된다.
*/



/* 각 패턴의 내용 정리

* Template Method Pattern (상속 기반)
Shape3.cpp 예제를 기반으로 설명
1. 템플릿 메소드(Draw() 메소드 의미)에서 알고리즘의 골격을 정의한다.
2. 알고리즘의 여러 단계중 변하는 부분(DrawImp())은 서브 클래스에서 구현한다. - 일명 Hook 메소드

알고리즘의 구조를 유지하면서 서브 클래스에서 특정 단계를 재정의 할 수 있는 패턴이라는 것!

* Strategy Pattern (포함 기반)
edit3.cpp 예제를 기반으로 설명
1. 알고리즘의 군(IValidator를 상속받은 클래스들)을 정의하고, 각각을 캡슐화 해서 교환하며 사용 할 수 있도록 만든다.
2. 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다.

*/

// 23가지의 패턴들이 있는데 템플릿, 전략 패턴만 잘이해해도 대부분이 유사해 빠르게 학습할 수 있다.