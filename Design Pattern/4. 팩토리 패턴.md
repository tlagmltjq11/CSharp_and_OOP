## Main Concept
Factory : 객체 생성을 처리하는 클래스
Factory Pattern : 객체를 생성하고자 할 때 사용하는 패턴


## Simple Factory Pattern
Simple factory는 팩토리 메소드 패턴과 추상 팩토리 패턴의 베이스가 된다.

참고로, simple factory는 디자인 '패턴'이라고 할 수는 없고, oop에서 자주 쓰이는 관용구라고 보면 된다.

이걸 이해해야 다른 factory pattern들의 이해도 쉬워진다.

 

Simple Factory 란?

객체를 생성해내는 공장을 따로 두는 것이다.

즉, 객체 생성 부분을 전담하는 클래스가 따로 있는 것이다. 

 

Pizza 객체 만드는 것을 예로 들어보자.

다양한 종류의 Pizza들(객체)이 있고, 피자 가게(Pizza Store)에 피자 주문(orderPizza)이 들어오면 가게에서 직접 객체(Pizza)를 생성할 수도 있다.

 

그러나 심플 팩토리에서는 이 객체의 생성만을 처리하는 공장(Pizza factory)을 따로 두는 것이다.

피자를 생성하는 작업을 한 클래스에 캡슐화시켜 놓았기 때문에, 수정 사항이 있을 때 여기저기 다 들어가서 고칠 필요 없이 factory class 하나만 고치면 되기 때문이다. 즉 수정이 용이할 것이고 이것은 유지 보수 비용이 적게 드는 것과 직결될 것이다.


Simple Factory는 객체를 생성하는 역할을 팩토리 클래스가 전담하게 하는 방법이다.
팩토리 패턴의 가장 기본이 된다.
OOP 에서 늘상 사용되기 때문에 패턴이라고 하기도 뭐하지만 팩토리 메서드와 추상 팩토리 패턴의 가장 기본이 되기 때문에 확실히 짚고 넘어가야 한다.
주어진 입력을 기반으로 다른 유형의 객체를 리턴하는 메소드가 있는 팩토리 클래스

⭐하나의 클래스로 여러가지 타입의 객체(자식)를 찍어내어 리턴하는 함수를 가진 하나의 공장(부모클래스)를 만든다. 다형성

여러개의 자식 오브젝트들을 하나의 함수로 쉽게 한방에 생성하기 위해 사용하는 패턴

객체 생성을 한군데에서만 관리할 수 있따는 장점이 있다.
여러 자식 타입들에게서 중복되는 내용을 제거할 수 있음.
객체를 생성하는 부분에 대한 코드 중복을 방지 할 수 있다.
 또 다른 클래스가 피자 객체를 생성해야 하는 상황이 생긴다면 이 SimplePizzaFactory를 이용하면 된다
 - 객체를 생성하는 부분을 한 클래스에 캡슐화함
Simple Factory의 장점은 이 한마디로 정리 될 수 있다.

객체를 생성하는 부분을 한 클래스에 캡슐화하면, 여러 클래스에서 어떤 클래스의 객체를 생성할 때, 그 클래스를 생성하는 코드 중복을 방지 할 수 있다.

가령 위의 예제에서 PizzaStore 클래스 뿐만 아니라, 피자에 대한 설명을 찾아서 활용하는 PizzaShopMenu 클래스, 피자를 준비 할 때 피자를 박스에 포장(box() 메소드 호출)한 후에 또 봉지에 싸서 포장해야하는 HomeDelivery 클래스가 추가되고, 피자의 메뉴에 변경이 발생하면 PizzaStore,PizzaShopMenu,HomeDelivery 세 클래스에서 피자 객체를 생성하는 부분을 수정해야하는 어려움이 있다.

하지만 객체 생성을 SimplePizzaFactory 클래스가 전담하면 SimplePizzaFactory 클래스만 수정하면 된다.

```c#
public class SimpleFactory : MonoBehaviour
{
    public static SimpleFactory instance = null;

    public GreenGoblin prefab_greenGoblin;
    public RedGoblin prefab_redGoblin;

    void Awake()
    {
        //싱글톤을 간단한 모양으로 구현.
        instance = this;
    }

    public Goblin CreateGoblin(string type)
    {
        Goblin goblin = null;

        if(type.Equals("green"))
        {
            goblin = Instantiate(prefab_greenGoblin);
        }
        else if(type.Equals("red"))
        {
            goblin = Instantiate(prefab_redGoblin);
        }

        return goblin;
    }
}
```

```c#
public class Scene1 : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        Goblin greenGoblin = SimpleFactory.instance.CreateGoblin("green");

        greenGoblin.SetPosition();
    }
}
```

하지만 위의 심플 팩토리로 게임을 만든다면 문제가 있다. 지금은 레드고블린과 그린고블린밖에 없지만, 오크, 트롤, 코볼트, 다크엘프 등등의 수많은 몬스터를 만들어야 한다고 해보자. 몬스터를 추가할 때마다 함수를 고치거나 몬스터별로 만들어야할 수도 있다. 이는 객체지향의 OCP(클래스 만들 때 확장은 가능하게 하되, 한번 만들면 추후에 수정할 필요 없게 만들라는 원칙)를 위반하는데다가 그냥 프로그래머팀 팀장님한테 설계 잘못했다고 욕먹을 수도 있다.

 

그래서 나온 디자인패턴이 팩토리 메소드와 추상팩토리 패턴이다.

## Factory Method Pattern

## Abstract Factory Pattern
