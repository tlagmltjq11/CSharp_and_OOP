## Main Concept
Factory : 객체 생성을 처리하는 클래스<br>
Factory Pattern : 객체를 생성하는 역할을 팩토리 클래스가 전담하게 하고자 할 때 사용하는 패턴<br>
<br>
<br>

## Simple Factory Pattern
Simple factory는 팩토리 메소드 패턴과 추상 팩토리 패턴의 베이스가 된다.<br>
그렇기 때문에 이걸 이해해야 다른 factory pattern들의 이해도 쉬워진다.<br>
참고로, simple factory는 디자인 '패턴'이라고 할 수는 없고, oop에서 자주 쓰이는 관용구라고 보면 된다.<br>

Simple Factory 란 객체를 생성해내는 공장을 따로 두는 것이다.<br>
즉, 객체 생성 부분을 전담하는 클래스가 따로 있는 것이다. <br>

Pizza 객체 만드는 것을 예로 들어보자 다양한 종류의 Pizza들(객체)이 있고, 피자 가게(Pizza Store)에<br>
피자 주문(orderPizza)이 들어오면 가게에서 직접 객체(Pizza)를 생성할 수도 있다.<br>

그러나 심플 팩토리에서는 이 객체의 생성만을 처리하는 공장(Pizza factory)을 따로 두는 것이다.<br>
피자를 생성하는 작업을 한 클래스에 캡슐화시켜 놓았기 때문에, 수정 사항이 있을 때 여기저기 다 들어가서 고칠 필요 없이<br>
factory class 하나만 고치면 되기 때문이다. 즉 수정이 용이할 것이고 이것은 유지 보수 비용이 적게 드는 것과 직결될 것이다.<br>
또 다른 클래스가 피자 객체를 생성해야 하는 상황이 생긴다면 이 SimplePizzaFactory를 이용하면 된다.<br>

Simple Factory의 장점은 이 한마디로 정리 될 수 있다.<br>
객체 생성 부분을 한 클래스에 캡슐화하여 관리할 수 있으며 객체를 생성하는 부분에 대한 코드 중복을 방지 할 수 있다.<br>
ex) A클래스에서도 객체가 필요하고 B클래스에서도 필요할 때 각자 객체 생성을 구현하는 코드 중복 상황을 방지<br>
<br>
<br>

예시 코드<br> 
```c#
public enum UnitType
{
	 Marine,
	 Firebat,
	 Medic
}

public class UnitFactory
{
    public static Unit createUnit(UnitType type)
    {
    	Unit unit = null;

	switch (type)
	{
        case UnitType.Marine:
            unit = new Marine();
            break;
            
        case UnitType.Firebat:
            unit = new Firebat();
            break;
            
        case UnitType.Medic:
            unit = new Medic();
            break;
	}
    
    	return unit;
    }
}

public class FactoryUse : MonoBehaviour 
{
   void Start () 
   {
       Unit unit1 = UnitFactory.createUnit(UnitType.Marine);
       Unit unit2 = UnitFactory.createUnit(UnitType.Firebat);
       Unit unit3 = UnitFactory.createUnit(UnitType.Medic);

       unit1.move();
       unit2.move();
       unit3.move();
   }
}
```
<br>
<br>

Simple Factory의 경우 Factory 클래스에서 생성해야 하는 Unit의 타입이 늘어날수록 분기문이 급수적으로 늘어나며<br>
타입별로 새로운 메서드를 생성해야 할 수도 있고 코드 중복의 가능성 문제가 존재한다.<br>
<br>
<br>

## Factory Method Pattern
생성하는 공장은 딱 하나. 그러나 어떻게 생성할지에 대한 여러 방식들을 공장의 자식 클래스들로 구현.
생성 함수를 따로 정의해주는 것이 팩토리 메소드 패턴의 요점이다.

다양한 자식들을 생성하고 리턴하는 팩토리 클래스는 딱 하나만 두고
어떤 방식으로 몇개 생성할지 등등 이런 어떤식으로 생성할지에 관한 생성의 형태는 팩토리 클래스를 상속하는 서브 팩토리 클래스들에게 맡긴다.
생성 형태는 여러가지가 있으므로 서브 팩토리 클래스들은 여러개가 있을 수 있다.
오브젝트 생산 공장 👉 팩토리 클래스 (부모)
오브젝트의 여러가지 생산 방식들 👉 서브 팩토리 클래스 (자식들)
부모인 팩토리 클래스로 서브 팩토리 클래스들을 참조하면, 팩토리 클래스 입장에선 뭘 어떻게 생성하는지 알 필요 없이 그냥 생성만 해주면 된다. 👉 다형성

유지 보수가 편리
생성 방식들을 추가/수정할땐 서브 팩토리 클래스 내용을 수정하거나 서브 팩토리 클래스 또 다른거 하나 더 추가하거나 그렇게만 하면 된다.
팩토리 클래스를 수정할 필요는 없다.

이렇게 되면 이 프로그램을 이용하는 피자가게가 늘어 날 때마다 if-else 문이 점점 늘어나게 된다.

이런 문제를 해결하기 위해서는 PizzaStore 클래스가 각 지역의 가게들 별로 나누어질 필요가 있다.

더 유연하게 대처 할 수 있다.

객체를 생성해내는 공장을 '인스턴스화'하여, 어떤 객체를 생성할지는 서브클래스에게 맡기는 방법이다.  

 

'Simple factory'에서 본 PizzaStore를 예로 들어보자.

 

PizzaStore 내부에 객체 생성만을 처리하는 createPizza()메소드를 추상 메소드로 선언한다. ->인스턴스화

그리고 PizzaStore를 상속받은 NYPizzaStore과 ChicagoPizzaStore에서 createPizza()메소드를 구현하며, 직접 필요한 객체를 생성한다. ->서브클래스에서 어떤 객체를 생성할지 결정한다.
심플 팩토리와 비교하자면, 생성하는 제품을 서브클래스에서 마음대로 변경할 수 있다는 큰 유연성을 주고 있다.

가장 큰 부분은 제품을 생산하는 부분과 사용하는 부분을 분리시킬 수 있다는 점이다.

(다시 말해, Creator 클래스가 ConcreteProduct와 느슨하게 결합되어 있다.)

따라서 다른 제품을 추가하거나 제품 구성을 변경시키더라도 제품을 생산하는 부분(Creator)은 건드릴 필요가 없다.

-> 결론은 유연성과 확장성이 뛰어남



출처: https://flower0.tistory.com/415 [개발자 라면]

Method Factory Pattern
위와 같이 팩토리 메소드 패턴을 이용하면, 피자를 만드는 활동(prepare, bake, cut, box)은 전부 PizzaStore에 국한시키면서도 분점(NYPizzaStore, ChicagoPizzaStore)마다 고유 스타일의 피자를 생성할 수 있다.

다시 정리하면, 피자 가게와 피자 제작 과정 전체를 하나로 묶어주는 프레임 워크를 만들었음에도 불구하고, 유연성도 잃지 않았다.
분기문도 분기문이지만 종속성을 완전 분리 하는 식으로 접근 해야 할 것 같습니다.

팩토리 메서드 패턴은 그냥 이곳저곳에서 클래스 파생해서 초기화하고 쓰고 하다보니 중복코드가 생겨서 보기싫은걸 한곳에 정리해놓은거라.. 사실 유니티는 프리팹으로 미리 세팅해놓고 생성하는게 더 좋기 때문에 그다지 쓰이지도 않아요; 복잡한 인게임 시스템이라면 또 모를까..

질문요지는 if-else문으로 늘여틀여서 초기화하고 리턴하는것과 상속받아서 세팅하고 리턴하는거가 뭐가 다르냐, 하는건데 제 생각에도 큰 차이는 없는거같아요. 그냥 후자가 더 코드가 깔끔하고 서로 분리되보이니까 관리하기는 좋겠죠

위키에서도 객체지향적으로 좋은 패턴은 아니라고 명시하고 있는데, 그냥 if-else문을 조금 이쁘게 정리한거니 당연하거겠죠. 그렇다고 안좋은 패턴은 아닌게, 파생클래스를 여러개 초기화해야 하는 상황이 생기면 중복코드는 생길수도 있기 마련이고 그때 유용하게 쓰이긴 할거에요

Template Method의 생성 패턴 버전으로 볼 수 있는데 Template Method를 알지 못한다면 그 패턴을 먼저 이해하는 것이 Factory Method를 이해하기 수월할 것이다.

Factory Method가 중첩되기 시작하면 굉장히 복잡해 질 수 있다. 또한 상속을 사용하지만 부모(상위) 클래스를 전혀 확장하지 않는다. 따라서 이 패턴은 extends 관계를 잘못 이용한 것으로 볼 수 있다. extends 관계를 남발하게 되면 프로그램의 엔트로피가 높아질 수 있으므로 Factory Method 패턴의 사용을 주의해야 한다.

```c#
abstract class UnitGenerator
{
    public List<Unit> units = new List<Unit>();

    public List<Unit> getUnits()
    {
        return units;
    }

    // Factory Method
    public abstract void CreateUnits(); 
}

class PatternGenerator_A : UnitGenerator
{
    public override void CreateUnits()
    {
        units.Add(new Marine());
        units.Add(new Marine());
        units.Add(new Marine());
        units.Add(new Marine());
        units.Add(new Marine());
        units.Add(new Marine());
        units.Add(new Marine());
        units.Add(new Marine());
    }
}

class PatternGenerator_B : UnitGenerator
{
    public override void CreateUnits()
    {
        units.Add(new Firebat());
        units.Add(new Firebat());
        units.Add(new Firebat());
        units.Add(new Marine());
        units.Add(new Marine());
        units.Add(new Marine());
        units.Add(new Marine());
    }
}

public class UseFactoryMethod : MonoBehaviour 
{
	UnitGenerator[] unitGenerators = null;

	void Start () 
	{
		unitGenerators = new UnitGenerator[2];
		unitGenerators[0] = new PatternGenerator_A();
		unitGenerators[1] = new PatternGenerator_B();
	}

	public void DoMakeTypeA()
	{
		unitGenerators[0].CreateUnits();
        	List<Unit> units = unitGenerators[0].getUnits();
		
        	foreach (Unit unit in units)
        	{
            	unit.Attack();
        	}
    	}

	public void DoMakeTypeB()
	{
		unitGenerators[1].CreateUnits();
        	List<Unit> units = unitGenerators[1].getUnits();
        	
		foreach (Unit unit in units)
        	{
           	 	unit.Attack();
      		}
    	}
}
```
<br>
<br>

## Abstract Factory Pattern
