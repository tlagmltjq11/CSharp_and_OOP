## Singleton Pattern
객체의 인스턴스가 오직 1개만 생성되도록 보장하고, 이에 대한 전역적인 접근을 제공하는 패턴이다.<br>
-> ⭐ **한 줄 정리 : 신중하게 전역변수에 올려놓고 어디서든 접근가능한 객체로 만드는 패턴** ⭐<br>
<br>

📜 코드예시<br>
```c#
using UnityEngine;
using System.Collections;
      
public class PointManager : MonoBehaviour 
{
    int myPoint = 0;
        
    static PointManager _instance = null;
    
      public static PointManager Instance()
      {
          return _instance;
      }
	  
      void Awake () 
      {
        if (_instance == null)
        {
            _instance = this;
            DontDestroyOnLoad(this.gameObject);
        }
        else 
        {
            if (this != _instance)
            {
                //새로 생성된 객체는 파괴
                Destroy(this.gameObject)
            }
        }
    }
        
    public void AddPoint(int num)
      {
        myPoint = myPoint + num;
      }
      
    public int GetPoint()
    {
        return myPoint;
    }
}
```
<br>
<br>

## 장점
1. 👉 최초 한번의 할당을 통해 고정된 메모리 영역을 사용하기 때문에 **추후 해당 객체에 접근할 때 메모리 낭비를 방지** 할 수 있다.

2. 👉 이미 생성된 인스턴스를 활용하니 **속도 측면**에서도 이점이 있다.
 
3. 👉 클래스 간 **데이터 공유가 쉽다.** (씬이 바뀌어도 데이터를 유지하며 공유 할 수 있다. **DontDestroyOnLoad**)
<br>

⭐⭐ **전체에 단 하나이기 때문에 따로 매번 오브젝트를 생성하거나 탐색해서 찾을 필요없이 instance 프로퍼티를 통해서 빠르게 접근할 수 있다.** ⭐⭐<br>
<br>
<br>

## 단점
1. 👉 모든 곳에서 접근이 가능하므로 **싱글톤 객체의 변경 시점, 변경 주체, 호출 시점을 모두 알기가 어렵다.**
 
2. 👉  **여러 클래스와 커플링이 된다.** ⭐⭐
-> 하나의 코드를 수정했을때, 싱글톤과 연결된 다양한 곳들에서 문제 발생<br>
-> 테스트가 까다로워지는 문제도 발생<br>

3. 👉 멀티 쓰레드 환경에서 문제 발생
-> 모든 곳에서 접근이 가능하므로 ⭐ **race condition** 발생.<br>
-> 이를 막기 위해 싱글톤은 ⭐⭐ **mutex lock, unlock을 반복적으로 걸기 때문에 코드의 성능은 떨어지게 된다.**<br>
<br>
<br>

## ⭐ 결론 ⭐
싱글톤 패턴의 장점은 프로그램에 단 하나여야 하는 클래스의 오브젝트를 다루는데 뛰어난 효율성을 보여준다는 것인데,
어떤 개발자들은 빠르고 편하게 사용할 수 있다는 점에 주목한다. 그리고 싱글톤 패턴의 모든 단점과 해악성은 여기에서 나온다.
오브젝트를 따로 탐색하거나 생성할 필요가 없이 바로 instance 호출로 바로 가져올 수 있다는 점에 취해서 쉽게 **남용되는 패턴**이 바로 싱글톤 패턴이다.
이 때문에 조금이라도 가져오기 어려운 오브젝트가 있으면 싱글톤 패턴으로 만들어버리거나, 기능을 싱글톤 패턴을 가진 오브젝트에 합쳐버리는 우를 범하게 된다.
일이 이렇게 진행되기 시작하면, 여기저기서 각기 다른 클래스의 instance를 호출하는 구조로 **코드의 흐름이 알기 어려워지고** 싱글톤 패턴을 가진 오브젝트의
**코드 크기는 점점 거대해져서 기형적으로 비대한 구조가 만들어지며**, 나중에는 따로 **분리해내거나 정리하기 어려워진다.**
때문에 싱글톤 패턴을 사용할 때는 편리함에 너무 취하지 않아야 하며, 해당 클래스가 너무 비대화되지 않는지, 
처리하기로 설계한 기능 이외의 것을 처리하려고 하고 있지 않은지를 **끊임없이 경계해야 한다.**<br>
-> 출처: https://wergia.tistory.com/192 [베르의 프로그래밍 노트]<br>
<br>
<br>

## Monobehaviour를 상속받지 않는 싱글톤
1. 👉 우선 씬 이동시의 신경을 안 써도 된다. 
씬 이동을 했을 때 그 씬의 Hierarchy에 같은 싱글톤 클래스가 존재한다면,<br>
기존씬에서 쓰던 인스턴스를 계속 쓸지, 아니면 새로운 씬의 Hierarchy에 있는 인스턴스를 쓸지를 선택해야한다. <br>
하지만 Monobehaviour를 상속받지 않고 메모리상에만 존재하게 한다면 이런 선택의 경우를 고려하지 않아도 돼서 편하다.<br>
<br>

2. 👉 현재 상용버전의 유니티 오브젝트라면 모두 갖게 될 Transform 컴포넌트를 안 가져도 되니 쓸데 없는 메모리 점유를 안해도 된다.
-> 하지만 눈에 안 보이면 헷갈릴 수도 있으니 보통은 인스펙터에서 관찰하기 위해 상속받아 사용한다.<br>
<br>
<br>
